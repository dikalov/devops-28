# Задание 1
# Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.
# Это встроенная команда bash, по названию и своему действию интуитивно понятная, так сказать перемещаемся по файловой директории.
#
# Задание 2
# Какая альтернатива без pipe для команды grep <some_string> <some_file> | wc -l?
# Данную команду можно упростить, которая используется для подсчёта строк с совпадениями, 
# например grep <some_string> <some_file> -c
# 
# Задание 3
# Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
# Команда pstree -p отвечает, что это systemd.
#
# Задание 4
# Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
# Сначала узнаем номер своего терминала tty (/dev/pts/0), потом lsof | grep pts (посмотрим список открытых терминалов)
# vagrant@vagrant:~$ ls /tmp1 (это на терминале 0)
# ls: cannot access '/tmp1': No such file or directory
# vagrant@vagrant:~$ ls /tmp1 2>/dev/pts/1   и эта команда перенаправит вывод команды ls /tmp1 на другой терминал.
#
# Задание 5
# Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.
# Да, это возможно. Для этого можно использовать следующую команду в терминале:
# command < input.txt > output.txt
# где `command` - это команда, которую мы хотим выполнить, `input.txt` - файл с входными данными, который будет использоваться как stdin для команды, и `output.txt` - файл, в который будет записываться stdout команды.
# Выполним команду `sort` , которая берет файл `input.txt` в качестве входных данных и сохранит результат в файл `output.txt`, то наша команда будет выглядеть следующим образом:
# sort < input.txt > output.txt
#
# Задание 6
# Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
# Да, это возможно, будем использовать утилиту `screen` для перенаправления вывода из PTY в эмулятор терминала.
# Открываем новый экран, выполнив следующую команду: screen -S myscreen
# На этом открывшемся экране запустим команду, например ls -lh
# Зажмём `Ctrl+A`, затем нажмите `D`. Это отсоединит экран `screen`, но сохранит его работу в фоновом режиме.Перейдём в другой терминал и подключимся к экрану `screen`, выполнив следующую команду: screen -r myscreen. Мы увидим вывод команды, которую мы запустили на первом терминале, в новом терминале.
# ![image](https://user-images.githubusercontent.com/126553776/229076580-211f9261-8428-4bb3-b490-d691fa277879.png)
# ![image](https://user-images.githubusercontent.com/126553776/229076960-d25e873f-fb0b-4895-a605-df56818543bb.png)
# ![image](https://user-images.githubusercontent.com/126553776/229077107-2c4d7418-af85-4728-9679-4258f7de1c95.png)
#
# Задание 7
# Выполните команду bash 5>&1. К чему она приведёт? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
# Эта команда в Bash создает новый файловый дескриптор (fd) 5, который указывает на тот же файл, что и дескриптор 1 (стандартный вывод stdout). Это означает, что вывод, который обычно отправляется в stdout, теперь будет отправляться и в дескриптор 5.
# Это нам пригодится если мы хотим перенаправить вывод определенных команд в файл или другой процесс, не затрагивая другие выводы. 
# Команда echo netology > /proc/$$/fd/5 перенаправляет вывод команды echo в файловый дескриптор 5 текущего процесса. Символ $$ здесь означает идентификатор текущего процесса. Если файловый дескриптор 5 был открыт на чтение, то при выполнении этой команды вывод будет перенаправлен в этот дескриптор, и в результате в файловый дескриптор 5 будет записано слово "netology". Если же файловый дескриптор 5 был открыт на запись, то в результате выполнения этой команды произойдет ошибка записи, так как файловый дескриптор 5 не связан с файлом, открытым на запись.
#
# Задание 8
# Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?
# Получится, cat ~/.profile dsds 2>&1 1>/dev/pts/0 | sed 's/cat/test/g' > test;
# `cat ~/.profile dsds` - команда `cat` будет выводить содержимое файла `~/.profile`(пользовательский файл конфигурации), а также выдаст сообщение об ошибке о том, что файла `dsds` не существует. Это сообщение об ошибке будет выведено в поток `stderr`.
# `2>&1` - этот фрагмент перенаправляет поток `stderr` на поток `stdout`, чтобы сообщение об ошибке также попало в pipe.
# `1>/dev/pts/0` - этот фрагмент перенаправляет поток `stdout` на терминал, связанный с псевдоустройством `pts/0`.
# `|` - символ pipe, который передает выходные данные предыдущей команды на вход следующей команде.
# `sed 's/cat/test/g'` - команда `sed` заменит все вхождения `cat` на `test`.
# `> test` - этот фрагмент перенаправит вывод команды `sed` в файл с именем `test`. Если файл не существует, он будет создан; если файл уже существует, его содержимое будет перезаписано.
# В результате выполнения данной команды будет выведено содержимое файла `~/.profile`, сообщение об ошибке о том, что файла `dsds` не существует, а также замененное на `test` содержимое файла, полученное из стандартного потока `stdin`. После этого содержимое будет сохранено в файл с именем `test`.
#
#
#

