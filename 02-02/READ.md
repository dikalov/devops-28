# Задание 1
# Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.
# Это встроенная команда bash, по названию и своему действию интуитивно понятная, так сказать перемещаемся по файловой директории.
#
# Задание 2
# Какая альтернатива без pipe для команды grep <some_string> <some_file> | wc -l?
# Данную команду можно упростить, которая используется для подсчёта строк с совпадениями, 
# например grep <some_string> <some_file> -c
# 
# Задание 3
# Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
# Команда pstree -p отвечает, что это systemd.
#
# Задание 4
# Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
# Сначала узнаем номер своего терминала tty (/dev/pts/0), потом lsof | grep pts (посмотрим список открытых терминалов)
# vagrant@vagrant:~$ ls /tmp1 (это на терминале 0)
# ls: cannot access '/tmp1': No such file or directory
# vagrant@vagrant:~$ ls /tmp1 2>/dev/pts/1   и эта команда перенаправит вывод команды ls /tmp1 на другой терминал.
#
# Задание 5
# Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.
# Да, это возможно. Для этого можно использовать следующую команду в терминале:
# command < input.txt > output.txt
# где `command` - это команда, которую мы хотим выполнить, `input.txt` - файл с входными данными, который будет использоваться как stdin для команды, и `output.txt` - файл, в который будет записываться stdout команды.
# Выполним команду `sort` , которая берет файл `input.txt` в качестве входных данных и сохранит результат в файл `output.txt`, то наша команда будет выглядеть следующим образом:
# sort < input.txt > output.txt
#
# Задание 6
# Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
# Да, это возможно, будем использовать утилиту `screen` для перенаправления вывода из PTY в эмулятор терминала.
# Открываем новый экран, выполнив следующую команду: screen -S myscreen
# На этом открывшемся экране запустим команду, например ls -lh
# Зажмём `Ctrl+A`, затем нажмите `D`. Это отсоединит экран `screen`, но сохранит его работу в фоновом режиме.Перейдём в другой терминал и подключимся к экрану `screen`, выполнив следующую команду: screen -r myscreen. Мы увидим вывод команды, которую мы запустили на первом терминале, в новом терминале.
# ![image](https://user-images.githubusercontent.com/126553776/229076580-211f9261-8428-4bb3-b490-d691fa277879.png)
# ![image](https://user-images.githubusercontent.com/126553776/229076960-d25e873f-fb0b-4895-a605-df56818543bb.png)
# ![image](https://user-images.githubusercontent.com/126553776/229077107-2c4d7418-af85-4728-9679-4258f7de1c95.png)
#
# Задание 7
# Выполните команду bash 5>&1. К чему она приведёт? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
# Эта команда в Bash создает новый файловый дескриптор (fd) 5, который указывает на тот же файл, что и дескриптор 1 (стандартный вывод stdout). Это означает, что вывод, который обычно отправляется в stdout, теперь будет отправляться и в дескриптор 5.
# Это нам пригодится если мы хотим перенаправить вывод определенных команд в файл или другой процесс, не затрагивая другие выводы. 
# Команда echo netology > /proc/$$/fd/5 перенаправляет вывод команды echo в файловый дескриптор 5 текущего процесса. Символ $$ здесь означает идентификатор текущего процесса. Если файловый дескриптор 5 был открыт на чтение, то при выполнении этой команды вывод будет перенаправлен в этот дескриптор, и в результате в файловый дескриптор 5 будет записано слово "netology". Если же файловый дескриптор 5 был открыт на запись, то в результате выполнения этой команды произойдет ошибка записи, так как файловый дескриптор 5 не связан с файлом, открытым на запись.
#
# Задание 8
# Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?
# Получится, cat ~/.profile dsds 2>&1 1>/dev/pts/0 | sed 's/cat/test/g' > test;
# `cat ~/.profile dsds` - команда `cat` будет выводить содержимое файла `~/.profile`(пользовательский файл конфигурации), а также выдаст сообщение об ошибке о том, что файла `dsds` не существует. Это сообщение об ошибке будет выведено в поток `stderr`.
# `2>&1` - этот фрагмент перенаправляет поток `stderr` на поток `stdout`, чтобы сообщение об ошибке также попало в pipe.
# `1>/dev/pts/0` - этот фрагмент перенаправляет поток `stdout` на терминал, связанный с псевдоустройством `pts/0`.
# `|` - символ pipe, который передает выходные данные предыдущей команды на вход следующей команде.
# `sed 's/cat/test/g'` - команда `sed` заменит все вхождения `cat` на `test`.
# `> test` - этот фрагмент перенаправит вывод команды `sed` в файл с именем `test`. Если файл не существует, он будет создан; если файл уже существует, его содержимое будет перезаписано.
# В результате выполнения данной команды будет выведено содержимое файла `~/.profile`, сообщение об ошибке о том, что файла `dsds` не существует, а также замененное в `test` содержимое файла, полученное из стандартного потока `stdin`. После этого содержимое будет сохранено в файл с именем `test`.
#
# Задание 9
# Что выведет команда cat /proc/$$/environ? Как ещё можно получить аналогичный по содержанию вывод?
# Команда `cat /proc/$$/environ` выведет переменные окружения текущей сессии в формате `переменная=значение`. Это позволяет увидеть, какие переменные окружения установлены в текущей сессии и их значения. 
# Можно также использовать команду `env` для вывода переменных окружения текущей сессии в удобном для чтения формате. Команда `env` без аргументов выводит список всех переменных окружения и их значений, которые были установлены в текущей сессии. Если необходимо вывести значение только одной переменной, можно использовать команду `echo $имя_переменной`, например, `echo $PATH`.
#
# Задание 10
# Используя man, опишите, что доступно по адресам
# Команда `man proc` позволяет получить информацию о файловой системе `procfs`, включая описание содержимого файла `/proc/<PID>/cmdline`. Согласно описанию, файл `/proc/<PID>/cmdline` содержит аргументы командной строки, используемые при запуске процесса с указанным идентификатором процесса (PID). 
#  Согласно описанию, файл `/proc/<PID>/exe` является символической ссылкой на исполняемый файл, который был использован при запуске процесса с указанным идентификатором процесса (PID). Если файл, на который указывает символическая ссылка `/proc/<PID>/exe`, был удален или перемещен, то ссылка будет указывать на файл с именем `[deleted]`. Это может произойти, например, если процесс был обновлен и исполняемый файл был заменен новой версией.
#
# Задание 11
# Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
# Ответ 4_2, судя по cat /proc/cpuin#fo | grep -o 'sse[0-9_]*' | sort -h | uniq
#
# Задание 12
# Почитайте, почему так происходит и как изменить поведение.
# 
#
# Задание 13
# Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
# Запустите новую сессию `screen` с помощью команды `screen`. Находим идентификатор терминала, на котором запущен нужный процесс, используя команду `ps aux | grep <название процесса>`.Запустим утилиту `reptyr` с идентификатором процесса и идентификатором новой сессии `screen`, используя следующую команду: `sudo reptyr -s <идентификатор новой сессии> <идентификатор процесса>`. ТО есть, если идентификатор новой сессии `screen` равен `12345`, а идентификатор процесса, который нужно переместить, равен `1234`, то команда будет выглядеть так:
# sudo reptyr -s 12345 1234
# После выполнения этой команды процесс будет перенесен в новую сессию `screen`, и мы сможем продолжить работу с ним в этой сессии.
#
# Задание 14 
# sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
# Команда `tee` используется для чтения стандартного ввода и записи его как выходных данных как в файл, так и в стандартный вывод. Таким образом, команда `echo string | sudo tee /root/new_file` сначала выводит строку "string" на стандартный вывод, а затем записывает ее в файл `/root/new_file`. Команда `sudo` здесь используется для выполнения операции записи в файл от имени суперпользователя.
# Как уже упоминалось ранее, команда `sudo echo string > /root/new_file` не будет работать, потому что перенаправление `>` выполняется процессом shell без прав суперпользователя. Однако, когда команда `sudo tee` используется вместо `sudo echo`, команда `tee` выполняется с правами суперпользователя, что позволяет успешно выполнить операцию записи в файл.
