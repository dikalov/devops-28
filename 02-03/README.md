## Задание 1
### Какой системный вызов делает команда cd? В прошлом ДЗ вы выяснили, что cd не является самостоятельной программой. Это shell builtin, поэтому запустить strace непосредственно на cd не получится. Вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
CD является встроенной командой оболочки (shell) и просто изменяет текущий рабочий каталог для текущего процесса. Чтобы изменить текущий каталог для другого процесса, нужно использовать системный вызов `chdir()`.
## Задание 2
### Используя strace, выясните, где находится база данных file, на основании которой она делает свои догадки.
В файле file_log можно найти информацию о том, где находится база данных, используемая file для определения типа файла. Для этого можно найти строки, содержащие подстроку "magic.mgc" или "magic.mime". 
### openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3. 
В нашем примере база данных находится в файле "/usr/share/misc/magic.mgc". Однако, местоположение базы данных может отличаться в зависимости от системы.
![image](https://user-images.githubusercontent.com/126553776/229482629-a2552372-4c8b-4544-abd1-ed52d4357770.png)
## Задание 3
### Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удалён (deleted в lsof), но сказать сигналом приложению переоткрыть файлы или просто перезапустить приложение возможности нет. Так как приложение продолжает писать в удалённый файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков, предложите способ обнуления открытого удалённого файла, чтобы освободить место на файловой системе.
Найдем этот файл: lsof -p PID процеса приложения | grep deleted, затем можно его обнулить `: > file_name.log`, где `file_name.log` - это имя удаленного файла, который требуется обнулить.  После выполнения этой команды, приложение продолжит писать в обнуленный файл, не замечая, что его содержимое было обнулено. Но для полного решения нужно установить ограничение на файл, ибо через некоторое время он снова заполнит память.
### sudo truncate -s 100M /proc/1234567/fd/4
`-s` указывает размер файла, а `100M` означает 100 мегабайт, 1234567 - PID, 4 - номер файлового дескриптора.
## Задание 4
### Занимают ли зомби-процессы ресурсы в ОС (CPU, RAM, IO)?
Зомби-процессы не занимают ресурсы процессора, оперативной памяти или ввода-вывода, потому что они не выполняют никаких действий. Зомби-процессы - это процессы, которые уже завершили свое выполнение, но еще не были полностью удалены из системы. Они не выполняют никаких операций, потому что процесс завершил свою работу и связанные с ним ресурсы были освобождены. Однако зомби-процессы могут занимать некоторое количество системных ресурсов, таких как идентификатор процесса (PID) и записи в таблице процессов, которые могут затруднять работу системы и работу пользователя, под которым они были запущены. Поэтому хорошей практикой является удаление зомби-процессов из системы как можно быстрее, чтобы избежать потенциальных проблем с производительностью или другими аспектами работы системы.
## Задание 5
### На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.
![image](https://user-images.githubusercontent.com/126553776/229495541-a7b3fe60-6fca-4b73-b328-6c705329152e.png)
![image](https://user-images.githubusercontent.com/126553776/229496048-48d6849d-8b21-4837-9801-5a83c280b866.png)
## Задание 6
### Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc и где можно узнать версию ядра и релиз ОС.
Команда `uname -a` использует системный вызов `uname()`. 
### Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
Как видно выше, альтернативное местоположение для получения информации, которую возвращает `uname()`, находится в `/proc` файловой системе. Например, версию ядра и релиз ОС можно узнать из файла `/proc/sys/kernel/version`.
## Задание 7
### Есть ли смысл использовать в bash &&, если применить set -e?
Команды, разделенные точкой с запятой (`;`), будут выполнены независимо от результата выполнения предыдущей команды. Например, если запустим команды `echo "Hello"; echo "World"`, то обе команды будут выполнены независимо от результата выполнения друг друга, и увидим на экране "Hello" и "World". Команды, разделенные двойным амперсандом (`&&`), будут выполнены только в случае успешного завершения предыдущей команды. Если предыдущая команда завершится с ошибкой, следующая команда не будет выполнена.
### set -e?
Команда `set -e` в Bash включает режим "exit immediately on error", то есть если в какой-либо команде возникает ошибка (например, она завершается с ненулевым кодом возврата), выполнение скрипта прекращается немедленно. Это может быть полезно, чтобы избежать выполнения неверных команд в скрипте и получить быстрый отказ, если что-то идет не так. Однако, если нужно выполнить несколько команд в рамках одного блока, и все они должны быть выполнены успешно, прежде чем перейти к следующему блоку, можно использовать оператор `&&`. Таким образом, использование оператора `&&` вместе с `set -e` может обеспечить более строгое управление ошибками при выполнении скриптов в Bash.
## Задание 8
### Из каких опций состоит режим bash set -euxo pipefail, и почему его хорошо было бы использовать в сценариях?
`-e` (или `errexit`) - это опция, которая заставляет скрипт выходить с ненулевым кодом возврата при возникновении любой ошибки в команде. Такой режим помогает избежать продолжения выполнения скрипта в случае возникновения ошибок, что может привести к непредсказуемым результатам. `-u` (или `nounset`) - это опция, которая заставляет скрипт выходить с ненулевым кодом возврата, если при попытке использования неопределенной переменной происходит ошибка. Такой режим помогает избежать ошибок, связанных с неправильным использованием переменных. `-x` (или `xtrace`) - это опция, которая заставляет скрипт выводить на экран каждую команду перед ее выполнением. Такой режим помогает отслеживать процесс выполнения скрипта и находить ошибки. `-o pipefail` - это опция, которая заставляет скрипт выходить с ненулевым кодом возврата, если любая команда в цепочке команд, объединенных оператором `|`, завершается с ненулевым кодом возврата. Такой режим помогает избежать проблем с обработкой ошибок при использовании конвейеров. Использование режима `bash set -euxo pipefail` в сценариях может помочь избежать многих ошибок и проблем, связанных с выполнением скриптов. Этот режим упрощает отладку и повышает надежность скриптов. Но нужно учесть, что некоторые команды могут завершаться с ненулевым кодом возврата при нормальном выполнении, поэтому использование этого режима может потребовать некоторых дополнительных настроек.
## Задание 9
### Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps изучите (/PROCESS STATE CODES), что значат дополнительные к основной заглавной букве статуса процессов. Его можно не учитывать при расчёте (считать S, Ss или Ssl равнозначными).
PROCESS STATE CODES
       Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the
       state of a process:

               D    uninterruptible sleep (usually IO)
               I    Idle kernel thread
               R    running or runnable (on run queue)
               S    interruptible sleep (waiting for an event to complete)
               T    stopped by job control signal
               t    stopped by debugger during the tracing
               W    paging (not valid since the 2.6.xx kernel)
               X    dead (should never be seen)
               Z    defunct ("zombie") process, terminated but not reaped by its parent

Чтобы определить, какой из статусов встречается наиболее часто, можно воспользоваться командой `sort` и `uniq -c`, которая позволит подсчитать количество каждого статуса и вывести его вместе с числом вхождений. Вот как будет выглядеть полная команда: ps -eo stat | sort | uniq -c | sort -rn. Эта команда выведет список статусов, отсортированных по количеству вхождений в порядке убывания. В самом начале списка будет наиболее часто встречающийся статус.
![image](https://user-images.githubusercontent.com/126553776/229507315-a25c861a-953f-40f0-87ba-78e2aeb7268e.png)
Наиболее часто встречающиеся процессы со stat S - процессы спящие, находятся в режиме ожидания, I - фоновые процессы ядра.
