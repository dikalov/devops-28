## Задание 1
### Какой системный вызов делает команда cd? В прошлом ДЗ вы выяснили, что cd не является самостоятельной программой. Это shell builtin, поэтому запустить strace непосредственно на cd не получится. Вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
CD является встроенной командой оболочки (shell) и просто изменяет текущий рабочий каталог для текущего процесса. Чтобы изменить текущий каталог для другого процесса, нужно использовать системный вызов `chdir()`.
## Задание 2
### Используя strace, выясните, где находится база данных file, на основании которой она делает свои догадки.
В файле file_log можно найти информацию о том, где находится база данных, используемая file для определения типа файла. Для этого можно найти строки, содержащие подстроку "magic.mgc" или "magic.mime". 
### openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3. 
В нашем примере база данных находится в файле "/usr/share/misc/magic.mgc". Однако, местоположение базы данных может отличаться в зависимости от системы.
![image](https://user-images.githubusercontent.com/126553776/229482629-a2552372-4c8b-4544-abd1-ed52d4357770.png)
## Задание 3
### Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удалён (deleted в lsof), но сказать сигналом приложению переоткрыть файлы или просто перезапустить приложение возможности нет. Так как приложение продолжает писать в удалённый файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков, предложите способ обнуления открытого удалённого файла, чтобы освободить место на файловой системе.
Найдем этот файл: lsof -p PID процеса приложения | grep deleted, затем можно его обнулить `: > file_name.log`, где `file_name.log` - это имя удаленного файла, который требуется обнулить.  После выполнения этой команды, приложение продолжит писать в обнуленный файл, не замечая, что его содержимое было обнулено. Но для полного решения нужно установить ограничение на файл, ибо через некоторое время он снова заполнит память.
### sudo truncate -s 100M /proc/1234567/fd/4
`-s` указывает размер файла, а `100M` означает 100 мегабайт, 1234567 - PID, 4 - номер файлового дескриптора.
## Задание 4
### Занимают ли зомби-процессы ресурсы в ОС (CPU, RAM, IO)?
Зомби-процессы не занимают ресурсы процессора, оперативной памяти или ввода-вывода, потому что они не выполняют никаких действий. Зомби-процессы - это процессы, которые уже завершили свое выполнение, но еще не были полностью удалены из системы. Они не выполняют никаких операций, потому что процесс завершил свою работу и связанные с ним ресурсы были освобождены. Однако зомби-процессы могут занимать некоторое количество системных ресурсов, таких как идентификатор процесса (PID) и записи в таблице процессов, которые могут затруднять работу системы и работу пользователя, под которым они были запущены. Поэтому хорошей практикой является удаление зомби-процессов из системы как можно быстрее, чтобы избежать потенциальных проблем с производительностью или другими аспектами работы системы.
## Задание 5
### На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.
![image](https://user-images.githubusercontent.com/126553776/229495541-a7b3fe60-6fca-4b73-b328-6c705329152e.png)
![image](https://user-images.githubusercontent.com/126553776/229496048-48d6849d-8b21-4837-9801-5a83c280b866.png)
## Задание 6
### Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc и где можно узнать версию ядра и релиз ОС.
Команда `uname -a` использует системный вызов `uname()`. 
### Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
Как видно выше, альтернативное местоположение для получения информации, которую возвращает `uname()`, находится в `/proc` файловой системе. Например, версию ядра и релиз ОС можно узнать из файла `/proc/sys/kernel/version`.
## Задание 7
### Есть ли смысл использовать в bash &&, если применить set -e?
Команды, разделенные точкой с запятой (`;`), будут выполнены независимо от результата выполнения предыдущей команды. Например, если вы запустите команды `echo "Hello"; echo "World"`, то обе команды будут выполнены независимо от результата выполнения друг друга, и вы увидите на экране "Hello" и "World". Команды, разделенные двойным амперсандом (`&&`), будут выполнены только в случае успешного завершения предыдущей команды. Если предыдущая команда завершится с ошибкой, следующая команда не будет выполнена.
### set -e?
Команда `set -e` в Bash включает режим "exit immediately on error", то есть если в какой-либо команде возникает ошибка (например, она завершается с ненулевым кодом возврата), выполнение скрипта прекращается немедленно. Это может быть полезно, чтобы избежать выполнения неверных команд в скрипте и получить быстрый отказ, если что-то идет не так. Однако, если нужно выполнить несколько команд в рамках одного блока, и все они должны быть выполнены успешно, прежде чем перейти к следующему блоку, можно использовать оператор `&&`. Таким образом, использование оператора `&&` вместе с `set -e` может обеспечить более строгое управление ошибками при выполнении скриптов в Bash.
