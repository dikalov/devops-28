## Задание 1

Есть скрипт:

```bash
a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
```

Какие значения переменным c, d, e будут присвоены? Почему?

| Переменная  | Значение | Обоснование |
| ------------- | ------------- | ------------- |
| `c`  |  a+b | т.к. a и b без символа $, а + воспринимается как оператор только в арифметических операциях; |
| `d`  | 1+2  | так как в данном выражении используется символ доллара перед переменной `a`, который обозначает использование значения переменной `a`, но при этом символ плюс не является математической операцией, а единственно строковой операцией конкатенации.  |
| `e`  | 3 | так как в данном выражении используется арифметический оператор сложения, заданный символами `$(())`, и переменным `a` и `b` будут присвоены свои числовые значения, а не строковые значения. |

----

## Задание 2

На нашем локальном сервере упал сервис, и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. После чего скрипт должен завершиться. 

В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на жёстком диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:

```bash
while ((1==1)
do
	curl https://localhost:4757
	if (($? != 0))
	then
		date >> curl.log
	fi
done
```

### Ваш скрипт:

```bash
while ((1==1))
do
	curl https://localhost:4757
	if (($? != 0))
	then
	date >> curl.log
	else
	break
	fi
	done
```
Правки: пропущена закрывающая скобка в первой строке условия `while`, а также поправил условие выхода из цикла при поднятии сервиса.

---

## Задание 3

Необходимо написать скрипт, который проверяет доступность трёх IP: `192.168.0.1`, `173.194.222.113`, `87.250.250.242` по `80` порту и записывает результат в файл `log`. Проверять доступность необходимо пять раз для каждого узла.

### Ваш скрипт:

```bash
#!/usr/bin/env bash
ip=("192.168.5.108" "192.168.5.162" "192.168.5.2")
port=80
a=5
while (($a > 0))
 do
  for i in ${ip[@]}
    do
      date >> nc.log
      nc -zv $i $port &>> nc.log
    done
    let "a=a-1"
 done

```

Этот скрипт выполняет проверку доступности указанных IP-адресов на порту 80 с помощью команды `nc`. Результаты проверки записываются в файл `nc.log`. В начале скрипта объявляются массив ip, в котором перечислены IP-адреса, которые необходимо проверить, а также переменная port, в которой указывается порт, на котором нужно выполнить проверку. Затем скрипт запускает цикл `while`, который будет выполняться до тех пор, пока переменная `a` больше 0. Внутри цикла `while` скрипт выполняет цикл `for`, который перебирает каждый IP-адрес из массива ip и выполняет команду `nc -zv $i $port` для проверки доступности на порту 80. Результаты проверки записываются в файл `nc.log` с помощью команды `&>>`. После завершения проверки всех IP-адресов, скрипт уменьшает значение переменной `a` на единицу с помощью команды `let "a=a-1"`. Таким образом, скрипт будет выполняться 5 раз.

---
## Задание 4

Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен — IP этого узла пишется в файл error, скрипт прерывается.

### Ваш скрипт:

```bash
#!/usr/bin/env bash
ip=("192.168.5.108" "192.168.5.162" "192.168.5.2")
port=80
while ((1==1))
 do
 for i in ${ip[@]}
   do
    nc -zv $i $port
    if (($? != 0))
    then
      echo $i > error
      exit 1
    fi
   done
 done
```
Скрипт запускает бесконечный цикл `while`, который будет выполняться до тех пор, пока не будет выполнена команда `exit 1`. В цикле `for` скрипт перебирает каждый IP-адрес из массива ip и выполняет команду `nc -zv $i $port` для проверки доступности на порту 80. Если команда выполняется успешно (возвращает 0), то скрипт продолжает работу и переходит к следующему IP-адресу. Если команда не выполняется успешно (возвращает значение отличное от 0), то скрипт записывает IP-адрес в файл error и завершает работу командой `exit 1`. Таким образом, данный скрипт может быть использован для мониторинга доступности определенных IP-адресов на порту 80 и автоматического уведомления в случае их недоступности.

---

## Задание со звёздочкой* 

Это самостоятельное задание, его выполнение необязательно.
____

Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для Git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках, и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.

### Ваш скрипт:

```bash
% nano .git/hooks/commit-msg
#!/usr/bin/env bash 

validator=$(grep -c "\[[[:digit:]]*-[[:alpha:]]*-[[:digit:]]*-[[:alpha:]]*\] *" "$1")
count=$(cat "$1" | wc -m )

if [[ "$validator" -eq "0" ]]; then 
    echo "Commit message does not match format: [number-section-number-lecture] message"
    echo 
    echo "Commit message:"
    cat $1 | grep -v ^#
    echo
    exit 1
elif [[ "$count" -gt "30" ]]; then 
    echo "The commit message must not exceed 30 characters. It turned out $count characters"
    echo 
    echo :"Commit message:"
    cat $1 | grep -v ^#
    echo
    exit 1
fi
exit 0
```
`% chmod +x .git/hooks/commit-msg`

Данный скрипт является хуком для системы контроля версий Git и запускается при выполнении команды `git commit`. Скрипт проверяет формат комментария к коммиту и его длину и возвращает соответствующий код возврата, который влияет на успешность коммита. При запуске скрипт получает аргумент `$1`, который содержит путь до файла с комментарием к коммиту. Скрипт будет выполнять две проверки:

1. Проверка формата комментария. С помощью команды `grep` в переменную `validator` сохраняется количество строк в файле, которые соответствуют шаблону "\[[[:digit:]]*-[[:alpha:]]*-[[:digit:]]*-[[:alpha:]]*\] *", т.е. строке вида "[number-section-number-lecture] message". Если количество строк равно 0, то скрипт выводит сообщение об ошибке и возвращает код возврата 1.

2. Проверка длины комментария. С помощью команды `cat` и `wc` в переменную `count` сохраняется количество символов в файле с комментарием. Если количество символов превышает 30, то скрипт выводит сообщение об ошибке и возвращает код возврата 1.

Если обе проверки пройдены успешно, скрипт возвращает код возврата 0, что позволяет успешно выполнить коммит.

Команда `nano .git/hooks/commit-msg` открывает файл commit-msg в текстовом редакторе Nano. Этот файл является скриптом, который вызывается при каждом коммите в Git. Открытие этого файла в текстовом редакторе позволяет редактировать его содержимое. Обычно этот файл используется для проверки сообщения коммита на соответствие определенным правилам, например, наличию номера задачи в заголовке коммита.

Команда `chmod +x .git/hooks/commit-msg` устанавливает права на исполнение для файла commit-msg в директории .git/hooks.

----

