## Задание 1
### Узнайте о sparse-файлах (разряженных).
Sparse-файлы (или разряженные файлы) - это файлы, которые содержат блоки нулевых байтов вместо фактического контента файлов. То есть, вместо того, чтобы записывать нули на диск, операционная система создает "метаданные" о блоках нулей, которые должны быть пропущены при чтении файла. Создание sparse-файла может быть полезным, когда мы создаем файл с большими пропусками или пустыми пространствами. Он позволяет сэкономить место на диске, так как фактический контент файла не записывается. Например, если мы создадим файл размером 1 Гб, состоящий из одних нулей, то фактически он будет занимать только несколько килобайтов на диске, если создать его как sparse-файл.

Чтобы создать разреженный файл (sparse-файл) заполненный нулями, можно использовать команду `dd` с опцией `seek` и без опции `count`(указывает количество блоков данных, которые будут скопированы). Например, следующая команда создаст разреженный файл "output10" размером 4 гигабайта, заполненный нулями:

dd if=/dev/zero of=output10 bs=1G seek=4

Здесь `dd` - это утилита командной строки для копирования и преобразования файлов. Опция `if` указывает исходный файл, в данном случае это `/dev/zero`, специальный файл в Linux, который генерирует поток нулей. Опция `of` указывает выходной файл, т.е. имя файла, который будет создан. Опция `bs` указывает размер блока данных, который будет записан в выходной файл, в данном случае 1 гигабайт. Опция `seek` указывает количество блоков данных, которые будут пропущены в выходном файле, перед началом записи данных. В данном случае `seek=4`, что означает, что будет создан файл размером 4 гигабайта, но на диске будут записаны только метаданные о блоках нулей, а фактический контент файла будет отсутствовать. Таким образом, команда создаст разреженный файл "output10" размером 4 гигабайта, но на диске он будет занимать только несколько килобайтов и будет полностью заполнен нулями.

А вот чтобы создать обычный файл, нужно использовать команду, которая очень похожа на команду для создания разреженного файла.

dd if=/dev/zero of=output5 bs=1G count=4

Здесь опция `count` указывает количество блоков данных, которые будут скопированы, т.е. в данном случае 4 блока размером 1 гигабайт каждый. Таким образом, команда создаст обычный файл "output5" размером 4 гигабайта, полностью заполненный нулями. На диске будут записаны фактические данные в виде нулей.
## Задание 2
### Могут ли файлы, являющиеся жёсткой ссылкой на один объект, иметь разные права доступа и владельца? Почему?
Нет, файлы, являющиеся жесткой ссылкой на один объект, не могут иметь разные права доступа и владельца. Жесткая ссылка - это дополнительное имя файла, которое указывает на тот же объект (например, файл) в файловой системе. При создании жесткой ссылки на файл создается новый файл с другим именем, но с тем же inode'ом (идентификатором) и содержимым. Права доступа и владелец - это атрибуты файла, которые хранятся в inode'е, связанном с файлом. Таким образом, все жесткие ссылки на один файл будут иметь одинаковые права доступа и владельца, поскольку они указывают на тот же inode. Если бы разные жесткие ссылки на один файл могли иметь разные права доступа и владельца, это привело бы к несогласованности и нарушению целостности файловой системы.
## Задание 3
### Сделайте vagrant destroy на имеющийся инстанс Ubuntu. Эта конфигурация создаст новую виртуальную машину с двумя дополнительными неразмеченными дисками по 2,5 Гб
![image](https://user-images.githubusercontent.com/126553776/230445154-52ac4f73-49fc-48dd-96a5-de0fc44c0f2a.png)

![image](https://user-images.githubusercontent.com/126553776/230445360-a473eaaa-c7f1-4249-a71c-4de456884f0a.png)
## Задание 4
### Используя fdisk, разбейте первый диск на два раздела: 2 Гб и оставшееся пространство.
![image](https://user-images.githubusercontent.com/126553776/230452011-e3e54447-f18f-4a96-9537-13544bded998.png)
## Задание 5
### Используя sfdisk, перенесите эту таблицу разделов на второй диск.
![image](https://user-images.githubusercontent.com/126553776/230453739-3ff3f280-675e-4e8e-8567-e5cbcbd06feb.png)

![image](https://user-images.githubusercontent.com/126553776/230453868-d8595504-42f3-43e7-ae42-36b49a389843.png)

Команда `sfdisk -d /dev/sdb > sdb.dump` используется для создания резервной копии таблицы разделов диска в файле `sdb.dump`. Опция `-d` используется для вывода таблицы разделов в удобочитаемом формате, который может быть использован для восстановления таблицы разделов в будущем. `/dev/sdb` - путь к диску, для которого нужно создать резервную копию таблицы разделов. `> sdb.dump` используется для перенаправления вывода команды в файл `sdb.dump`. Команда `sfdisk -d /dev/sdb > sdb.dump` создаст файл `sdb.dump`, содержащий информацию о таблице разделов диска `/dev/sdb`.

Команда `sfdisk /dev/sdc < sdb.dump` используется для восстановления таблицы разделов диска из ранее созданной резервной копии в файле `sdb.dump`. `/dev/sdc` - путь к диску, для которого нужно восстановить таблицу разделов. `< sdb.dump` используется для перенаправления содержимого файла `sdb.dump` в качестве входных данных для команды `sfdisk`. Команда `sfdisk /dev/sdc < sdb.dump` прочитает содержимое файла `sdb.dump`, который содержит информацию о таблице разделов, и восстановит эту таблицу разделов на диске `/dev/sdc`. 

## Задание 6
### Соберите mdadm RAID1 на паре разделов 2 Гб.
![image](https://user-images.githubusercontent.com/126553776/230457170-9128a99a-b458-4f1b-a0c3-456d109828d1.png)

Команда `mdadm --create --verbose /dev/md0 -l 1 -n 2 /dev/sd{b1,c1}` используется для создания RAID-массива уровня 1 с двумя дисками `/dev/sdb1` и `/dev/sdc1`. Здесь `md0` - это имя устройства, которое будет использоваться для обращения к массиву, `-l 1` указывает на выбор уровня RAID, где уровень 1 используется для зеркалирования данных, а `-n 2` указывает на количество дисков, которые будут использоваться в массиве. `/dev/sd{b1,c1}` - это путь к дискам, которые будут использоваться для создания массива. Ключ `--verbose` используется для вывода подробной информации о процессе создания массива.

## Задание 7
### Соберите mdadm RAID0 на второй паре маленьких разделов.
![image](https://user-images.githubusercontent.com/126553776/230462339-54409365-582b-44d0-a29e-8718bab9a988.png)

## Задание 8
### Создайте два независимых PV на получившихся md-устройствах.
![image](https://user-images.githubusercontent.com/126553776/230463349-e1bb9a18-9f87-4b0f-a45d-5a426bc823b5.png)

Команда `pvcreate /dev/md0 /dev/md1` используется для создания физических томов (physical volumes) на двух устройствах `/dev/md0` и `/dev/md1`. Физические тома используются в LVM (Logical Volume Manager) для логического объединения нескольких физических дисков в один большой том. Команда `pvcreate` создает метаданные на выбранных устройствах, которые затем могут быть использованы для создания логических томов (logical volumes).

## Задание 9
### Создайте общую volume-group на этих двух PV.
![image](https://user-images.githubusercontent.com/126553776/230464715-7088cf87-713e-499b-b2a7-7944cc52f105.png)

Команда `vgcreate volume-group /dev/md0 /dev/md1` используется для создания новой группы томов (volume group) с именем `volume-group` на основе двух физических томов `/dev/md0` и `/dev/md1`. Группа томов - это объединение физических томов вместе, которые могут быть логически разбиты на один или несколько логических томов (logical volumes).

## Задание 10
### Создайте LV размером 100 Мб, указав его расположение на PV с RAID0.
![image](https://user-images.githubusercontent.com/126553776/230469269-bbd00226-ad0f-4a7b-a87b-f5bb7552c07e.png)

Команда `lvcreate -L 100m -n vgroup volume-group /dev/md1` создает новый логический том (logical volume) с именем `vgroup` в группе томов (volume group) `volume-group` на физическом томе `/dev/md1`. Опция `-L` задает размер нового логического тома. В данном случае, размер равен 100 мегабайтам. Опция `-n` указывает имя нового логического тома. 

## Задание 11
### Создайте mkfs.ext4 ФС на получившемся LV.
![image](https://user-images.githubusercontent.com/126553776/230543231-01f76dff-a1b9-4f05-8b75-397b3af42389.png)

Команда `mkfs.ext4 /dev/volume-group/vgroup` используется для создания файловой системы ext4 на логическом томе `/dev/volume-group/vgroup`. Эта команда форматирует логический том и создает на нем файловую систему, которая может быть использована для хранения файлов и данных.

## Задание 12
### Смонтируйте этот раздел в любую директорию, например, /tmp/new.
![image](https://user-images.githubusercontent.com/126553776/230545212-97df9316-9123-4d83-a41b-7967015543a8.png)

Команда `mount /dev/volume-group/vgroup /tmp/new/` используется для монтирования файловой системы, которая находится на логическом томе `/dev/volume-group/vgroup`, в каталог `/tmp/new/`.

## Задание 13
### Поместите туда тестовый файл, например, wget https://mirror.yandex.ru/ubuntu/ls-lR.gz -O /tmp/new/test.gz.
![image](https://user-images.githubusercontent.com/126553776/230546025-7b820175-7ff3-44eb-9bca-c33c1f63b6e1.png)

## Задание 14
### Прикрепите вывод lsblk.
![image](https://user-images.githubusercontent.com/126553776/230546515-b86ec6b3-3d8d-4a5e-8a4e-db670c93289a.png)

## Задание 15
### Протестируйте целостность файла:
![image](https://user-images.githubusercontent.com/126553776/230547196-fda50fc5-adb6-4af6-810b-bca50017753b.png)

## Задание 16
### Используя pvmove, переместите содержимое PV с RAID0 на RAID1.
![image](https://user-images.githubusercontent.com/126553776/230548005-7682dc51-c379-4073-8ec2-b58cb1b63ced.png)

Команда `pvmove -n /dev/volume-group/vgroup /dev/md1 /dev/md0` используется для перемещения логического тома `vgroup`, который находится на физическом томе `/dev/md1`, на другой физический том `/dev/md0` в группе томов `volume-group`. Это может пригодиться, если нужно изменить конфигурацию группы томов, переместить данные с одного физического диска на другой или распределить нагрузку между несколькими физическими дисками. У нас же команда перемещает данные логического тома `vgroup` с физического тома `/dev/md1` на физический том `/dev/md0`. Опция `-n` указывает имя логического тома. 

## Задание 17
### Сделайте --fail на устройство в вашем RAID1 md.
![image](https://user-images.githubusercontent.com/126553776/230552462-9014ccb2-8577-4ae6-95e8-a5db09880961.png)

Команда `mdadm /dev/md0 -f /dev/sdb1` используется для пометки диска `/dev/sdb1` как «отказавшего» в RAID-массиве `/dev/md0`. Когда диск помечается как «отказавший», это означает, что он больше не будет использоваться в массиве. Система автоматически перестроит массив, используя только те диски, которые не были помечены как отказавшие. Это позволяет обеспечить безопасность данных в случае отказа одного или нескольких дисков в массиве. Команда `mdadm` используется для управления RAID-массивами в Linux. Опция `-f` указывает, что диск `/dev/sdb1` должен быть помечен как отказавший. Опция `-r` используется для удаления диска из массива. 

## Задание 18
### Подтвердите выводом dmesg, что RAID1 работает в деградированном состоянии.
![image](https://user-images.githubusercontent.com/126553776/230552695-10472c2c-6cef-49c6-8dff-403f54b7b4ee.png)

Команда `dmesg | grep md0 | tail -n 2` используется для вывода последних двух строк из журнала системных сообщений (dmesg), которые содержат информацию о RAID-массиве с именем `md0`. Оператор `|` используется для передачи вывода команды `dmesg` на вход команды `grep`, которая ищет строки, содержащие ключевое слово `md0`. Оператор `tail -n 2` используется для вывода последних двух строк из вывода команды `grep`.

## Задание 19
### Протестируйте целостность файла — он должен быть доступен несмотря на «сбойный» диск:
![image](https://user-images.githubusercontent.com/126553776/230552918-445af573-7b0f-4479-b07e-a223afe767b0.png)

## Задание 20
### Погасите тестовый хост — vagrant destroy.
C:\Users\dikalovdg\devops-netology\vagrant>vagrant destroy

default: Are you sure you want to destroy the 'default' VM? [y/N] y

==> default: Forcing shutdown of VM...

==> default: Destroying VM and associated drives...
