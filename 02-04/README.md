## Задание 1
### На лекции вы познакомились с node_exporter. В демонстрации его исполняемый файл запускался в background. Этого достаточно для демо, но не для настоящей production-системы, где процессы должны находиться под внешним управлением. Используя знания из лекции по systemd, создайте самостоятельно простой unit-файл для node_exporter: поместите его в автозагрузку; предусмотрите возможность добавления опций к запускаемому процессу через внешний файл (посмотрите, например, на systemctl cat cron); удостоверьтесь, что с помощью systemctl процесс корректно стартует, завершается, а после перезагрузки автоматически поднимается.
![image](https://user-images.githubusercontent.com/126553776/229877543-6432d8f1-69be-4579-b770-fcd96ea3de79.png)
![image](https://user-images.githubusercontent.com/126553776/229877775-61fd5f9e-a220-410f-9649-99aada26f165.png)
![image](https://user-images.githubusercontent.com/126553776/229879032-29ad0f9c-0998-4367-858a-fe06971ce106.png)
## Задание 2
### Изучите опции node_exporter и вывод /metrics по умолчанию. Приведите несколько опций, которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.
`web.listen-address` - определяет адрес, по которому node_exporter будет прослушивать запросы. Например, можно указать `0.0.0.0:9100`, чтобы разрешить запросы со всех IP-адресов.

`web.telemetry-path` - определяет путь, по которому метрики будут доступны. По умолчанию этот путь установлен на `/metrics`.

`--collector.cpu.info` - определяет, будет ли собираться информация о процессоре, включая количество ядер и их частоту.

`--collector.meminfo` - определяет, будет ли собираться информация о памяти, включая общий объем и использование.

`--collector.diskstats` - определяет, будет ли собираться информация о дисках, включая количество операций чтения/записи и количество ошибок.

`--collector.netdev` - определяет, будет ли собираться информация о сетевых интерфейсах, включая количество переданных и полученных пакетов.

`--collector.tcpstat` - определяет, будет ли собираться информация о подключениях TCP, включая количество открытых подключений, количество ошибок и т.д.

`--collector.time` - определяет, будет ли собираться информация о системном времени, включая загрузку системы и время работы.
## Задание 3
### После успешной перезагрузки в браузере на своём ПК (не в виртуальной машине) вы должны суметь зайти на localhost:19999. Ознакомьтесь с метриками, которые по умолчанию собираются Netdata, и с комментариями, которые даны к этим метрикам.
После как разрешил порт sudo ufw allow 19999, всё получилось:
![image](https://user-images.githubusercontent.com/126553776/230308377-e0929639-8a13-40e4-85f3-cc532653f646.png)
## Задание 4
### Можно ли по выводу dmesg понять, осознаёт ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?
Да, по выводу dmesg можно понять, осознает ли операционная система, что загружена в виртуализированной среде. Обычно, если ОС работает в виртуализированной среде, она может выдавать сообщения о том, что она работает в режиме виртуализации или что некоторые функции могут работать не так, как в реальной среде.

В выводе dmesg можно найти следующие сообщения:
- "Hypervisor detected: KVM" - это сообщение говорит о том, что ОС работает в виртуализированной среде KVM;
- "Booting paravirtualized kernel on bare hardware" - это сообщение говорит о том, что ОС работает в режиме виртуализации пара-виртуализации на реальном оборудовании.
![image](https://user-images.githubusercontent.com/126553776/230314311-1bd63776-8282-4ce6-b247-b45bae169313.png)
## Задание 5
### Как настроен sysctl fs.nr_open на системе по умолчанию? Определите, что означает этот параметр. Какой другой существующий лимит не позволит достичь такого числа (ulimit --help)?
Параметр sysctl fs.nr_open устанавливает максимальное количество файловых дескрипторов, которые могут быть открыты системой. Это означает, что если процесс попытается открыть еще один файл, когда максимальное количество дескрипторов уже открыто, то операция будет отклонена.

На большинстве систем по умолчанию значение параметра sysctl fs.nr_open равно 1048576. На моей машине также.

Также существуют другие лимиты, такие как ограничение на количество открытых файловых дескрипторов для каждого процесса. Этот лимит устанавливается с помощью команды ulimit и может ограничивать количество открытых файловых дескрипторов для каждого процесса, даже если максимальное количество дескрипторов, установленное в sysctl, не было достигнуто. Чтобы узнать текущий лимит на количество открытых файловых дескрипторов для каждого процесса, можно использовать команду `ulimit -n`.

![image](https://user-images.githubusercontent.com/126553776/230319084-11b9c61f-7039-4648-bdf9-b998af99622c.png)

Команда ulimit -Sn устанавливает мягкий лимит на максимальное количество открытых дескрипторов файлов (file descriptor) для текущего пользователя в системе. Это ограничение применяется к количеству открытых файловых дескрипторов на уровне процесса. Мягкий лимит является рекомендуемым ограничением и может быть изменен самим пользователем в пределах установленного жесткого лимита. При превышении мягкого лимита, процесс может продолжать работу, но при этом может возникнуть проблема с открытием новых файлов, что может привести к ошибкам в работе программы.

Команда ulimit -Hn устанавливает жесткий лимит на максимальное количество открытых дескрипторов файлов (file descriptor) для текущего пользователя в системе. Это ограничение применяется к количеству открытых файловых дескрипторов на системном уровне, и может быть установлено только администратором системы. Установка этого жесткого лимита гарантирует, что пользователь не сможет открыть больше файлов, чем это ограничение. При попытке открытия большего количества файлов, чем разрешено, система выдаст ошибку "Too many open files".
## Задание 6
### Запустите любой долгоживущий процесс (не ls, который отработает мгновенно, а, например, sleep 1h) в отдельном неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через nsenter. Для простоты работайте в этом задании под root (sudo -i). Под обычным пользователем требуются дополнительные опции (--map-root-user) и т. д.
![image](https://user-images.githubusercontent.com/126553776/230327141-22192d46-26ec-46b3-9aeb-2dfa55686539.png)
## Задание 7
### Найдите информацию о том, что такое :(){ :|:& };:. Запустите эту команду в своей виртуальной машине Vagrant с Ubuntu 20.04 (это важно, поведение в других ОС не проверялось). Некоторое время всё будет плохо, после чего (спустя минуты) — ОС должна стабилизироваться. Вызов dmesg расскажет, какой механизм помог автоматической стабилизации. Как настроен этот механизм по умолчанию, и как изменить число процессов, которое можно создать в сессии?
Это называется "функция fork-бомбы" (fork bomb function) и представляет собой опасный участок кода на языке программирования Bash. Эта функция fork рекурсивно вызывающая сама себя до тех пор пока не забьёт все ресурсы системы. В результате этой функции процессы на системе будут увеличиваться экспоненциально и могут вызвать сбой или отказ в работе системы.
![image](https://user-images.githubusercontent.com/126553776/230329817-1fb11af0-e336-4b3b-ad08-58ef2726b345.png)

[ 9734.460580] cgroup: fork rejected by pids controller in /user.slice/user-1000.slice/session-11.scope

Это сообщение предупреждает о том, что попытка создания нового процесса отклонена контроллером PIDs в рамках cgroup. Cgroups (Control groups) - это механизм ядра Linux, который позволяет ограничивать, изолировать и отслеживать ресурсы, потребляемые группами процессов. Контроллер PIDs управляет ограничением количества процессов, которые можно создать в рамках cgroup. В нашем случае, сообщение об ошибке указывает на то, что было превышено ограничение на количество процессов, которые можно создать в рамках данного cgroup.

Параметры по умолчанию можно поглядеть:

![image](https://user-images.githubusercontent.com/126553776/230344489-6abb27bd-3743-4cf8-abb1-5af785b4d96f.png)



