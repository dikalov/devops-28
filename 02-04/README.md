## Задание 1
### На лекции вы познакомились с node_exporter. В демонстрации его исполняемый файл запускался в background. Этого достаточно для демо, но не для настоящей production-системы, где процессы должны находиться под внешним управлением. Используя знания из лекции по systemd, создайте самостоятельно простой unit-файл для node_exporter: поместите его в автозагрузку; предусмотрите возможность добавления опций к запускаемому процессу через внешний файл (посмотрите, например, на systemctl cat cron); удостоверьтесь, что с помощью systemctl процесс корректно стартует, завершается, а после перезагрузки автоматически поднимается.
![image](https://user-images.githubusercontent.com/126553776/229877543-6432d8f1-69be-4579-b770-fcd96ea3de79.png)
![image](https://user-images.githubusercontent.com/126553776/229877775-61fd5f9e-a220-410f-9649-99aada26f165.png)
![image](https://user-images.githubusercontent.com/126553776/229879032-29ad0f9c-0998-4367-858a-fe06971ce106.png)
## Задание 2
### Изучите опции node_exporter и вывод /metrics по умолчанию. Приведите несколько опций, которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.
`web.listen-address` - определяет адрес, по которому node_exporter будет прослушивать запросы. Например, можно указать `0.0.0.0:9100`, чтобы разрешить запросы со всех IP-адресов.

`web.telemetry-path` - определяет путь, по которому метрики будут доступны. По умолчанию этот путь установлен на `/metrics`.

`--collector.cpu.info` - определяет, будет ли собираться информация о процессоре, включая количество ядер и их частоту.

`--collector.meminfo` - определяет, будет ли собираться информация о памяти, включая общий объем и использование.

`--collector.diskstats` - определяет, будет ли собираться информация о дисках, включая количество операций чтения/записи и количество ошибок.

`--collector.netdev` - определяет, будет ли собираться информация о сетевых интерфейсах, включая количество переданных и полученных пакетов.

`--collector.tcpstat` - определяет, будет ли собираться информация о подключениях TCP, включая количество открытых подключений, количество ошибок и т.д.

`--collector.time` - определяет, будет ли собираться информация о системном времени, включая загрузку системы и время работы.
## Задание 3
### После успешной перезагрузки в браузере на своём ПК (не в виртуальной машине) вы должны суметь зайти на localhost:19999. Ознакомьтесь с метриками, которые по умолчанию собираются Netdata, и с комментариями, которые даны к этим метрикам.
После как разрешил порт sudo ufw allow 19999, всё получилось:
![image](https://user-images.githubusercontent.com/126553776/230308377-e0929639-8a13-40e4-85f3-cc532653f646.png)
## Задание 4
### Можно ли по выводу dmesg понять, осознаёт ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?
Да, по выводу dmesg можно понять, осознает ли операционная система, что загружена в виртуализированной среде. Обычно, если ОС работает в виртуализированной среде, она может выдавать сообщения о том, что она работает в режиме виртуализации или что некоторые функции могут работать не так, как в реальной среде.

В выводе dmesg можно найти следующие сообщения:
- "Hypervisor detected: KVM" - это сообщение говорит о том, что ОС работает в виртуализированной среде KVM;
- "Booting paravirtualized kernel on bare hardware" - это сообщение говорит о том, что ОС работает в режиме виртуализации пара-виртуализации на реальном оборудовании.
![image](https://user-images.githubusercontent.com/126553776/230314311-1bd63776-8282-4ce6-b247-b45bae169313.png)
## Задание 5
### Как настроен sysctl fs.nr_open на системе по умолчанию? Определите, что означает этот параметр. Какой другой существующий лимит не позволит достичь такого числа (ulimit --help)?

