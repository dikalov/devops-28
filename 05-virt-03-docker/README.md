## Задание 1
### Опубликуйте созданный fork в своём репозитории и предоставьте ответ в виде ссылки
Скачиваем образ nginx:
```docker pull nginx```

Создаем dockerfile:

```
FROM nginx
RUN echo '<html><head>Hey, Netology</head><body><h1>I am DevOps Engineer!</h1></body></html>' > /usr/share/nginx/html/index.html
```
Делаем fork образа: ```docker build -f Dockerfile -t dikalow/devops-28:5.3 .```

Пушим образ в наш репозиторий(предварительно залогинившись): ```docker push dikalow/devops-28:5.3```

Запустим контейнер с пробросом на 8080 порт хоста: ```docker run -d -p 8080:80 dikalow/devops-28/netology:5.3```

Ссылка на образ: https://hub.docker.com/repository/docker/dikalow/devops-28/tags?page=1&ordering=last_updated

![image](https://github.com/dikalov/devops-28/assets/126553776/4c743e33-e167-4654-9e60-4329ba8ab9c0)

## Задание 2
### Посмотрите на сценарий ниже и ответьте на вопрос: «Подходит ли в этом сценарии использование Docker-контейнеров или лучше подойдёт виртуальная машина, физическая машина? Может быть, возможны разные варианты?» Детально опишите и обоснуйте свой выбор.

Высоконагруженное монолитное Java веб-приложение - физическая машина, чтобы не расходовать ресурсы на виртуализацию и не будет проблем с разворачиванием на разных машинах.

Nodejs веб-приложение - Docker, так как это веб-платформа с подключаемыми внешними библиотеками.

Мобильное приложение c версиями для Android и iOS - виртуальные машины, проще для тестирования, размещения на одной хостовой машине.

Шина данных на базе Apache Kafka - Docker, есть готовые образы для apache kafka, изолированность приложений, а также легкий откат на стабильные версии в случае обнаружения багов.

Elasticsearch-кластер для реализации логирования продуктивного веб-приложения — три ноды elasticsearch, два logstash и две ноды kibana - Docker, Elasticsearch доступен для установки как образ docker, проще удалять логи, удобнее при кластеризации - меньше времени на запуск контейнеров.

Мониторинг-стек на базе Prometheus и Grafana - Docker, есть готовые образы, приложения не хранят данные, что удобно при контейниризации, удобно масштабировать и быстро разворачивать.

MongoDB как основное хранилище данных для Java-приложения - зависит от нагрузки на DB. Если нагрузка большая, то физический сервер, если нет – VM.

Gitlab-сервер для реализации CI/CD-процессов и приватный (закрытый) Docker Registry - подойдет VM для DB и фалового хранилища, Docker для сервисов.

## Задание 3
### Запустите первый контейнер из образа centos c любым тегом в фоновом режиме, подключив папку /data из текущей рабочей директории на хостовой машине в /data контейнера. Запустите второй контейнер из образа debian в фоновом режиме, подключив папку /data из текущей рабочей директории на хостовой машине в /data контейнера. Подключитесь к первому контейнеру с помощью docker exec и создайте текстовый файл любого содержания в /data. Добавьте ещё один файл в папку /data на хостовой машине. Подключитесь во второй контейнер и отобразите листинг и содержание файлов в /data контейнера.

Запускаем первый контейнер ```docker run -v /data:/data --name centos-container -d -t centos```

Запускаем второй контейнер ```docker run -v /data:/data --name debian-container -d -t debian```

Посмотрим запущенные контейнеры:

![image](https://github.com/dikalov/devops-28/assets/126553776/cf9faf50-5732-4aae-b24a-49bc20ad9da1)

Подключаемся к первому контейнеру с помощью docker exec и создаем текстовый файл в /data

```docker exec centos-container /bin/bash -c "echo test_message>/data/readme.md"```

Добавим еще один файл в папку /data на хостовой машине:

``` 
sudo touch /data/readme_centos.md
sudo nano /data/readme_centos.md
```

